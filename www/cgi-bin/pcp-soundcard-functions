#!/bin/sh

# Version: 3.20 2017-02-26
#	Added check for /tmp/dropdown.cfg in pcp_sound_card_dropdown. SBP.
#	Added shini conf parser. SBP.

# Version: 3.11 2017-01-20
#	Fixed the issue with shairport not working when using USB cards. SBP.

# Version: 3.10 2016-12-11
#	Original. SBP.

DACLOCATION="/usr/local/etc/pcp/cards"
#DACLOCATION="/home/tc/www/cgi-bin/cards"

#. /usr/local/bin/shini.sh
# shini - portable INI library for sh (with extras for bash)
#
# This code is released freely under the MIT license - see the shipped LICENSE document.
# For the latest version etc, please see https://github.com/wallyhall/shini
#

shini_function_exists()
{
	type "$1" > /dev/null 2>&1
	return $?
}

# @param inifile Filename of INI file to parse
# @param postfix Function postfix for callbacks (optional)
# @param extra Extra argument for callbacks (optional)
shini_parse()
{

	RX_KEY='[a-zA-Z0-9_\-]'
	RX_VALUE="[^;\"]"
	RX_SECTION='[a-zA-Z0-9_\-]'
	RX_WS='[ 	]'
	RX_QUOTE='"'
	RX_HEX='[0-9A-F]'
	POSTFIX=''
	EXTRA1=''
	EXTRA2=''
	EXTRA3=''
	
	if [ $# -ge 2 ] && [ ! -z "$2" ]; then
	    POSTFIX="_$2"
	fi
	
	if [ $# -ge 3 ] && ! [ -z "$3" ]; then
	    EXTRA1="$3"
	fi
	
	if [ $# -ge 4 ] && [ ! -z "$4" ]; then
	    EXTRA2="$4"
	fi
	
	if [ $# -ge 5 ] && [ ! -z "$5" ]; then
	    EXTRA3="$5"
	fi
	
	if ! shini_function_exists "__shini_parsed${POSTFIX}"; then
		printf 'shini: __shini_parsed%s function not declared.\n' "${POSTFIX}" 1>&2
		exit 255
	fi

	if [ $# -lt 1 ]; then
		if shini_function_exists "__shini_no_file_passed{$POSTFIX}"; then
			"__shini_no_file_passed${POSTFIX}" "$EXTRA1" "$EXTRA2" "$EXTRA3"
		else
			printf 'shini: Argument 1 needs to specify the INI file to parse.\n' 1>&2
			exit 254
		fi
	fi
	INI_FILE="$1"

	if [ ! -r "$INI_FILE" ]; then
		if shini_function_exists "__shini_file_unreadable${POSTFIX}"; then
			"__shini_file_unreadable${POSTFIX}" "$INI_FILE" "$EXTRA1" "$EXTRA2" "$EXTRA3"
		else
			printf 'shini: Unable to read INI file:\n  `%s`\n' "$INI_FILE" 1>&2
			exit 253
		fi
	fi

	# Iterate INI file line by line
	LINE_NUM=0
	SECTION=''
	while read LINE || [ -n "$LINE" ]; do  # -n $LINE catches final line if not empty
		# Check for new sections
		if printf '%s' "$LINE" | \
		  grep -qe "^${RX_WS}*\[${RX_SECTION}${RX_SECTION}*\]${RX_WS}*$"; then
			SECTION="$(printf '%s' "$LINE" | \
				sed "s/^${RX_WS}*\[\(${RX_SECTION}${RX_SECTION}*\)\]${RX_WS}*$/\1/")"
				
            if shini_function_exists "__shini_parsed_section${POSTFIX}"; then
				"__shini_parsed_section${POSTFIX}" "$SECTION" "$EXTRA1" "$EXTRA2" "$EXTRA3"
			fi
			
			continue
		fi
		
		# Check for new values
		if printf '%s' "$LINE" | \
		  grep -qe "^${RX_WS}*${RX_KEY}${RX_KEY}*${RX_WS}*="; then
			KEY="$(printf '%s' "$LINE" | \
				sed "s/^${RX_WS}*\(${RX_KEY}${RX_KEY}*\)${RX_WS}*=.*$/\1/")"
			VALUE="$(printf '%s' "$LINE" | \
				sed "s/^${RX_WS}*${RX_KEY}${RX_KEY}*${RX_WS}*=${RX_WS}*${RX_QUOTE}\{0,1\}\(${RX_VALUE}*\)${RX_QUOTE}\{0,1\}\(${RX_WS}*\;.*\)*$/\1/")"
			
			if printf '%s' "$VALUE" | grep -qe "^0x${RX_HEX}${RX_HEX}*$"; then
				VALUE=$(printf '%d' "$VALUE")
			fi
			
			"__shini_parsed${POSTFIX}" "$SECTION" "$KEY" "$VALUE" "$EXTRA1" "$EXTRA2" "$EXTRA3"
						
			if shini_function_exists "__shini_parsed_comment${POSTFIX}"; then
			    if printf '%s' "$LINE" | grep -q ";"; then
        			COMMENT="$(printf '%s' "$LINE" | \
    	    			sed "s/^.*\;\(.*\)$/\1/")"
        			 "__shini_parsed_comment${POSTFIX}" "$COMMENT" "$EXTRA1" "$EXTRA2" "$EXTRA3"
    	        fi
            fi
            
			continue
		fi
		
		# Announce parse errors
		if [ "$LINE" != '' ] &&
		  ! printf '%s' "$LINE" | grep -qe "^${RX_WS}*;.*$" &&
		  ! printf '%s' "$LINE" | grep -qe "^${RX_WS}*$"; then
			if shini_function_exists "__shini_parse_error${POSTFIX}"; then
				"__shini_parse_error${POSTFIX}" $LINE_NUM "$LINE" "$EXTRA1" "$EXTRA2" "$EXTRA3"
			else
				printf 'shini: Unable to parse line %d:\n  `%s`\n' $LINE_NUM "$LINE"
			fi
		fi
		
		LINE_NUM=$((LINE_NUM+1))
	done < "$INI_FILE"

}

# @param inifile Filename of INI file to write to
# @param section Section of INI file to write to
# @param variable Variable name to add/update/delete
# @param value Value to add/update, do not specify to delete
shini_write()
{
    # This is not yet optimised (early write support only) - 
    # We actually re-parse the entire file, looking for the location in which to
    # write the new value, writing out everything we parse as-is meanwhile.

    # Declare the following if you want particular behaviour (like skipping
    # broken INI file content or handling an unreadable file etc).
    #  __shini_no_file_passed__writer()
    #  __shini_file_unreadable__writer()
    #  __shini_parse_error__writer()
    
    # Writer callbacks, used for writing the INI file content
    __shini_parsed_section__writer()
    {
        # Validate the last section wasn't the target section
        if [ "$LAST_SECTION" = "$WRITE_SECTION" ]; then
            # If it was, and the value wasn't written already, write it
            if [ $VALUE_WRITTEN -eq 0 ]; then
                printf "\n%s=%s" "$WRITE_KEY" "$WRITE_VALUE" >> "$INI_FILE_TEMP"
                VALUE_WRITTEN=1
            fi
        fi
        printf "\n[%s]" "$1" >> "$INI_FILE_TEMP"
        
        LAST_SECTION="$1"
    }
    
    __shini_parsed_comment__writer()
    {
        printf ";%s" "$1" >> "$INI_FILE_TEMP"
    }
    
    __shini_parsed__writer()
    {
        if [ "$1" = "$WRITE_SECTION" ]; then
            if [ "$2" = "$WRITE_KEY" ]; then
                if [ ! -z "$WRITE_VALUE" ]; then
                    printf "\n%s=%s" "$WRITE_KEY" "$WRITE_VALUE" >> "$INI_FILE_TEMP"
                fi
                VALUE_WRITTEN=1
                return
            fi
        fi
        
        printf "\n%s=%s" "$2" "$3" >> "$INI_FILE_TEMP"
    }
    
    if [ $# -lt 3 ]; then
        if shini_function_exists "__shini_no_file_passed"; then
            __shini_no_file_passed
        else
            printf 'shini: Argument 1 needs to specify the INI file to write.\n' 1>&2
            exit 254
        fi
    fi
    
    INI_FILE="$1"
    INI_FILE_TEMP="$(mktemp -t shini_XXXXXX)"       
    
    WRITE_SECTION="$2"
    WRITE_KEY="$3"
    WRITE_VALUE="$4"
    LAST_SECTION=""
    VALUE_WRITTEN=0
    
    shini_parse "$1" "_writer" "$2" "$3" "$4"
    # Still not written out yet
    if [ $VALUE_WRITTEN -eq 0 ]; then
        # Check if final existing section was target one, add it if not
        if [ "$LAST_SECTION" != "$WRITE_SECTION" ]; then
            printf "\n[%s]" "$WRITE_SECTION" >> "$INI_FILE_TEMP"
        fi
        # Write value at end of file
        printf "\n%s=%s" "$WRITE_KEY" "$WRITE_VALUE" >> "$INI_FILE_TEMP"
    fi
    
    mv "$INI_FILE_TEMP" "$INI_FILE"
}


#========================================================================================
# Check if we use the special Audio kernel or not. As we load special overlays if using Audio kernel
#----------------------------------------------------------------------------------------
pcp_AudioKernel_status() {
	sudo  uname -a | grep pcpAudioCore > /dev/null 2>&1 && KERNELVERSION=Audiokernel || KERNELVERSION=Officialkernel
}

#========================================================================================
# Disable/re_enable analog audio
#----------------------------------------------------------------------------------------
pcp_disable_analog() {
	sudo sed -i 's/^dtparam=audio=on/#dtparam=audio=on/g' $CONFIGTXT
	sudo sed -i 's/^audio_pwm_mode=2/#audio_pwm_mode=2/g' $CONFIGTXT
}

pcp_re_enable_analog() {
	pcp_disable_analog
	sudo sed -i "/dtparam=audio=on/c\dtparam=audio=on" $CONFIGTXT
	sudo sed -i "/audio_pwm_mode=2/c\audio_pwm_mode=2" $CONFIGTXT
}

#========================================================================================
# Remove Audio dtoverlays
#----------------------------------------------------------------------------------------
pcp_disable_i2s() {
	pcp_re_enable_analog
	# Get a list of all available sound card overlays
	for i in $AUDIO_OPTIONS_EXTRA; do
		# unset DTOVERLAY
		. "$DACLOCATION"/"$i".conf
		[ x"" != x"${DTOVERLAY}" ] && sed -i '/dtoverlay='"$DTOVERLAY"'/d' $CONFIGTXT
	done
}

#========================================================================================
# Add Audio dtoverlays
#----------------------------------------------------------------------------------------
pcp_enable_i2s() {
	pcp_re_enable_analog
	pcp_selected_soundcontrol
	[ x"$SPARAMS1" != x"" ] && PAR1=','"$SPARAMS1"'' || PAR1="$SPARAMS1"
	[ x"$SPARAMS2" != x"" ] && PAR2=','"$SPARAMS2"'' || PAR2="$SPARAMS2"
	[ x"$SPARAMS3" != x"" ] && PAR3=','"$SPARAMS3"'' || PAR3="$SPARAMS3"
	[ x"$SPARAMS4" != x"" ] && PAR4=','"$SPARAMS4"'' || PAR4="$SPARAMS4"
	[ x"$SPARAMS5" != x"" ] && PAR5=','"$SPARAMS5"'' || PAR5="$SPARAMS5"

	[ x"$DTOVERLAY" != x"" ] && sudo echo dtoverlay=$DTOVERLAY$PAR1$PAR2$PAR3$PAR4$PAR5  >> $CONFIGTXT
}

#=========================================================================================
# Enable/disable HDMI settings in config.txt
#-----------------------------------------------------------------------------------------
pcp_disable_HDMI() {
	sed -i '/hdmi_drive=2/d' $CONFIGTXT
	sed -i '/hdmi_force_hotplug=1/d' $CONFIGTXT
	sed -i '/hdmi_force_edid_audio=1/d' $CONFIGTXT
}

pcp_enable_HDMI() {
	pcp_disable_i2s
	sudo echo hdmi_drive=2 >> $CONFIGTXT
	sudo echo hdmi_force_hotplug=1 >> $CONFIGTXT
	sudo echo hdmi_force_edid_audio=1 >> $CONFIGTXT
	sudo amixer cset numid=3 2 >/dev/null 2>&1
}

#========================================================================================================
# Section that controls loading of DAC overlays
#--------------------------------------------------------------------------------------------------------
pcp_read_chosen_audio() {
	pcp_mount_mmcblk0p1
	pcp_disable_HDMI
	pcp_disable_i2s
	pcp_enable_i2s
	# This is to allow no unmount of mmcblk0p1 during booting with newconfig.cfg
	[ "$1" != "noumount" ] && pcp_umount_mmcblk0p1
}

#========================================================================================
# Control of sound card routines:
#  - Needs to be populated for each type of soundcard.
#  - Some are without filter options.
#  - USB cards will probably never be supported this way as they are so different.
#----------------------------------------------------------------------------------------
# HELP - To find the controls:
#  - amixer -c 0 scontrols
#  - aplay -l
#----------------------------------------------------------------------------------------
pcp_generic_card_control() {
	case "$GENERIC_CARD" in
		TI51XX)
			DSP="DSP Program,0"
			FILTER1="Low latency IIR with de-emphasis"
			FILTER2="FIR interpolation with de-emphasis"
			FILTER3="High attenuation with de-emphasis"
			FILTER4="Fixed process flow"
			FILTER5="Ringing-less low latency FIR"
			ACTUAL_VOL=$(amixer -c $CARD sget $SSET | grep "Right: Playback" | awk '{ print $5 }' | tr -d "[]%")
			ACTUAL_DB=$(amixer -c $CARD sget $SSET | grep "Right: Playback" | awk '{ print $6 }' | tr -d "[]")
			ACTUAL_FILTER=$(amixer -c $CARD sget 'DSP Program,0' | grep "Item0:" | awk '{ print $2 }' | tr -d "'")

			case "$DSPFILTER" in
				FILTER1) FILTER="Low latency IIR with de-emphasis" ;;
				FILTER2) FILTER="FIR interpolation with de-emphasis" ;;
				FILTER3) FILTER="High attenuation with de-emphasis" ;;
				FILTER4) FILTER="Fixed process flow" ;;
				FILTER5) FILTER="Ringing-less low latency FIR" ;;
			esac

			# Logic to make checked radiobuttons - needs to clear it otherwise we have two FILTERS_CHECK checked.
			FILTER1_CHECK=""
			FILTER2_CHECK=""
			FILTER3_CHECK=""
			FILTER4_CHECK=""
			FILTER5_CHECK=""

			case "$ACTUAL_FILTER" in
				Low) FILTER1_CHECK="checked" ;;
				FIR) FILTER2_CHECK="checked" ;;
				High) FILTER3_CHECK="checked" ;;
				Fixed) FILTER4_CHECK="checked" ;;
				Ringing-less) FILTER5_CHECK="checked" ;;
			esac
		;;

		HIFIBERRY_AMP)
			ACTUAL_VOL=$(amixer -c $CARD sget $SSET | grep "Mono:" | awk '{ print $3 }' | tr -d "[]%")
		;;

		ONBOARD)
			CARD="ALSA"
			ACTUAL_VOL=$(amixer -c $CARD sget $SSET | grep "Mono: Playback" | awk '{ print $4 }' | tr -d "[]%")
			ACTUAL_DB=$(amixer -c $CARD sget $SSET | grep "Mono: Playback" | awk '{ print $5 }' | tr -d "[]")
			TEXT=""
		;;

#		ES9023)
#			CARD="ALSA"
#			SSET="PCM"
#			ACTUAL_VOL=$(amixer -c $CARD sget $SSET | grep "Mono: Playback" | awk '{ print $4 }' | tr -d "[]%")
#			ACTUAL_DB=$(amixer -c $CARD sget $SSET | grep "Mono: Playback" | awk '{ print $5 }' | tr -d "[]")
#			TEXT="Choosing 384k will enable 352k and 384k sample rates. Selecting bclk_ratio_int_div will use bclk_ratio=50 for 16/24bps and bclk_ratio=100 for 32bps media when sample rate is a multiple of 8kHz and less than 192kHz. Which causes the selection of the 19M2 OSC as the parent for the PCM clock with an integer divider, rather than PLLD with fractional divider and MASH noise shaping."
#			PARAMS1="384k"
#			PARAMS2="bclk_ratio_int_div"
#		;;
	esac
}

#========================================================================================================
# This will get us all avaiable AUDIO DACs
#--------------------------------------------------------------------------------------------------------
AUDIO_OPTIONS_EXTRA=$(ls "$DACLOCATION" | grep ".conf" | awk -F'.conf' '{ print $1 }')

#========================================================================================================
# Section that populate sound card drop-down list on Squeezelite.cgi
#--------------------------------------------------------------------------------------------------------
pcp_sound_card_dropdown() {
	pcp_AudioKernel_status
	pcp_blank_audio_conf
	. $CONFIGCFG
	if [ -e /tmp/dropdown.cfg ]; then
		sudo sed -i 's/:selected:/:notselected:/' /tmp/dropdown.cfg
		sudo sed -i "/${AUDIO}:/s/:notselected:/:selected:/" /tmp/dropdown.cfg

	else
		CONF_AUDIO="$AUDIO"
		pcp_blank_audio_conf
		for i in $AUDIO_OPTIONS_EXTRA; do
			AUDIO=$i
			pcp_soundcontrol
			CHECKED="notselected"
			[ "$AUDIO" = "$CONF_AUDIO" ] && CHECKED="selected"
			sudo echo "${AUDIO}:${CHECKED}:${LISTNAME}:${RPI_MODEL}" >> /tmp/dropdown.cfg
		done
	fi
}

#========================================================================================================
# This will get us available options from the DAC
#--------------------------------------------------------------------------------------------------------
old_pcp_soundcontrol() {
	pcp_blank_audio_conf
	echo "$AUDIO_OPTIONS_EXTRA" | grep -q "$AUDIO" && . "$DACLOCATION"/"$AUDIO".conf
}



# Declare a handler for parsed variables.  This is required.
__shini_parsed()
{
#   printf "  %s_%s='%s'\n" "$1" "$2" "$3"
   eval \ $1_$2='"$3"'

if [ "$KERNELVERSION" = "Audiokernel" ]; then
	if [ "$1" = "PCPAUDIOCORE" ]; then
#	printf "  %s_%s='%s'\n" "$1" "$2" "$3"
	eval \ $2='"$3"'
	fi
fi

if [ "$KERNELVERSION" = "Officialkernel" ]; then
	if [ "$1" = "PCPCORE" ]; then
#	printf "  %s_%s='%s'\n" "$1" "$2" "$3"
	eval \ $2='"$3"'
	fi
fi

if [ $1 = "COMMON" ]; then
# 	printf "  %s_%s='%s'\n" "$1" "$2" "$3"
	eval \ $2='"$3"'
fi
	
}

pcp_soundcontrol() {
	# Parse
	shini_parse $DACLOCATION/$AUDIO.conf
}


#========================================================================================================
# This will get us available options from the selected DAC
#--------------------------------------------------------------------------------------------------------
pcp_selected_soundcontrol() {
	pcp_AudioKernel_status
	pcp_blank_audio_conf
	. "$CONFIGCFG"
	shini_parse $DACLOCATION/$AUDIO.conf
}

pcp_blank_audio_conf() {
	# Remove left-over from previous audio DAC
	CARD=""
	OUTPUT=""
	ALSA_PARAMS=""
	GENERIC_CARD=""
	CONTROL_PAGE=""
	LISTNAME=""
	DTOVERLAY=""
	TEXT=""
	SSET=""
	PARAMS1=""
	PARAMS2=""
	PARAMS3=""
	PARAMS4=""
	PARAMS5=""
	RPI_MODEL=""
}
