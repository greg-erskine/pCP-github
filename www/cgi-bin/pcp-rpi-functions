#!/bin/sh
# pcp-rpi-functions
# These are the common Raspberry Pi functions used by piCorePlayer

# Version: 0.10 2016-03-01 GE
#	Added support for Raspberry Pi 3B (not tested)

# Version: 0.09 2016-02-14 GE
#	Updated temperature function.
#	Updated for Raspberry Pi Zero.

# Version: 0.08 2015-11-27 GE
#	Added Raspberry Pi Zero (not tested)

# Version: 0.07 2015-09-19 GE
#	Added pcp_rpi_shortname.

# Version: 0.06 2015-05-30 GE
#	Added pcp_rpi_warranty.

# Version: 0.05 2015-03-13 GE
#	Added pcp_rpi_model_unknown, *0013 B+ and *0014 CM.

# Version: 0.05 2015-02-27 SBP
#	Fixed support for Raspberry Pi 2 Model B.

# Version: 0.04 2015-02-05 GE
#	Added support for Raspberry Pi 2 Model B.

# Version: 0.03 2014-12-08 SBP
#	Added support for Raspberry Pi Model A+.

# Version: 0.02 2014-10-26 GE
#	Added pcp_rpi_thermal and pcp_rpi_thermal_temp.

# Version: 0.01 2014-10-22 GE
#	Original.

#=========================================================================================
# Determine revisions and features of Raspberry Pi
#-----------------------------------------------------------------------------------------
# References:
#   http://elinux.org/RPi_HardwareHistory#Board_Revision_History
#   http://www.raspberrypi.org/forums/viewtopic.php?f=63&t=32733&p=301930&hilit=revision+identification&sid=e70960c27964330d9677de2eff077b80#p301930
#   http://raspberryalphaomega.org.uk/2013/02/06/automatic-raspberry-pi-board-revision-detection-model-a-b1-and-b2/
#   git://git.drogon.net/wiringPi

# For RPi1:
#    100000e
#    |  ---- Revision
#    Warranty bit

# For RPi2:
#    [USER:8] [NEW:1] [MEMSIZE:3] [MANUFACTURER:4] [PROCESSOR:4] [TYPE:8] [REV:4]
#    NEW            23: will be 1 for the new scheme, 0 for the old scheme
#    MEMSIZE        20: 0=256M    1=512M    2=1G
#    MANUFACTURER   16: 0=SONY    1=EGOMAN  2=EMBEST
#    PROCESSOR      12: 0=2835    1=2836    
#    TYPE           04: 0=MODELA  1=MODELB  2=MODELA+  3=MODELB+  4=MODEL 2B  5=ALPHA???
#                       6=CM      7=???     8=MODEL 3B  9=ZERO
#    REV            00: 0=REV0    1=REV1    2=REV2

#    *a21041
#    ||||||1=REV1
#    |||||4=Pi2 MODEL B
#    ||||0=2835
#    |||1=EGOMAN
#    ||2=1G
#    |USER
#    Warranty bit
#-----------------------------------------------------------------------------------------
pcp_rpi_revision() {
	awk -F: '/^Revision/ { print $2 }' /proc/cpuinfo | sed 's/ //g'
}

pcp_rpi_details() {
	case $(pcp_rpi_revision) in
		*Beta)  MODEL=B;    PCBREV=Beta; MEMORY=256;;
		*0002)  MODEL=B;    PCBREV=1;    MEMORY=256;;
		*0003)  MODEL=B;    PCBREV=1+;   MEMORY=256;;
		*0004)  MODEL=B;    PCBREV=2;    MEMORY=256;;
		*0005)  MODEL=B;    PCBREV=2;    MEMORY=256;;
		*0006)  MODEL=B;    PCBREV=2;    MEMORY=256;;
		*0007)  MODEL=A;    PCBREV=2;    MEMORY=256;;
		*0008)  MODEL=A;    PCBREV=2;    MEMORY=256;;
		*0009)  MODEL=A;    PCBREV=2;    MEMORY=256;;
		*000d)  MODEL=B;    PCBREV=2;    MEMORY=512;;
		*000e)  MODEL=B;    PCBREV=2;    MEMORY=512;;
		*000f)  MODEL=B;    PCBREV=2;    MEMORY=512;;
		*0010)  MODEL=B+;   PCBREV=1.2;  MEMORY=512;;
		*0011)  MODEL=CM;   PCBREV=1.0;  MEMORY=512;;
		*0012)  MODEL=A+;   PCBREV=1;    MEMORY=256;;
		*0013)  MODEL=B+;   PCBREV=1.2;  MEMORY=512;;
		*0014)  MODEL=CM;   PCBREV=1.1;  MEMORY=512;;		# Check PCBREV
		*0015)  MODEL=A+;   PCBREV=1.1;  MEMORY=256;;
		*041)   MODEL=2B;   PCBREV=1;    MEMORY=1024;;
		*092)   MODEL=ZERO; PCBREV=1;    MEMORY=512;;		# Check PCBREV
		*082)   MODEL=3B;   PCBREV=1.2;  MEMORY=1024;;		# a22082
		*)      MODEL=?;    PCBREV=?;    MEMORY=?;;
	esac

	case "${MODEL}${PCBREV}" in
		B1)    HARDWARE=BCM2708; ETHER=1; USB=2; LED=5; P2PINS=1; HOLES=0; PIN3=0; PIN5=1; PIN13=21; I2C=0; P5=0; P6=0;;
		B1+)   HARDWARE=BCM2708; ETHER=1; USB=2; LED=5; P2PINS=0; HOLES=0; PIN3=0; PIN5=1; PIN13=21; I2C=0; P5=0; P6=0;;
		B2)    HARDWARE=BCM2708; ETHER=1; USB=2; LED=5; P2PINS=0; HOLES=2; PIN3=1; PIN5=2; PIN13=27; I2C=1; P5=8; P6=2;;
		A2)    HARDWARE=BCM2708; ETHER=0; USB=1; LED=2; P2PINS=0; HOLES=2; PIN3=1; PIN5=2; PIN13=27; I2C=1; P5=8; P6=2;;
		B+*)   HARDWARE=BCM2708; ETHER=1; USB=4; LED=2; P2PINS=0; HOLES=4; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
		CM*)   HARDWARE=BCM2708; ETHER=0; USB=0; LED=X; P2PINS=0; HOLES=0; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
		A+*)   HARDWARE=BCM2708; ETHER=0; USB=1; LED=2; P2PINS=0; HOLES=4; PIN3=1; PIN5=2; PIN13=X;  I2C=X; P5=X; P6=X;;
		2B*)   HARDWARE=BCM2709; ETHER=1; USB=4; LED=2; P2PINS=0; HOLES=4; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
		ZERO*) HARDWARE=BCM2708; ETHER=0; USB=1; LED=2; P2PINS=0; HOLES=4; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
		3B*)   HARDWARE=BCM2710; ETHER=1; USB=4; LED=2; P2PINS=0; HOLES=4; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
		*)     HARDWARE=X;       ETHER=X; USB=X; LED=X; P2PINS=X; HOLES=X; PIN3=X; PIN5=X; PIN13=X;  I2C=X; P5=X; P6=X;;
	esac
}

pcp_pb_get() {
	echo $1 | tr a-zA-Z n-za-mN-ZA-M
}

#=========================================================================================
# Model
#-----------------------------------------------------------------------------------------
pcp_rpi_model() {
	pcp_rpi_details
	echo $MODEL
}

pcp_rpi_model_unknown() {
	pcp_rpi_details
	[ $MODEL = ? ] && echo 0 || echo 1
}

pcp_rpi_shortname() {
	pcp_rpi_details
	SHORTMAC=$(pcp_eth0_mac_address)
	([ $MODEL = A ] || [ $MODEL = A+ ]) && SHORTMAC=$(pcp_wlan0_mac_address)
	SHORTMAC=$(echo $SHORTMAC | sed 's/://g')
	echo "RPi-$(pcp_rpi_model)-${SHORTMAC:6}"
}

pcp_rpi_is_model_A() {
	pcp_rpi_details
	[ $MODEL = A ] && echo 0 || echo 1
}

pcp_rpi_is_model_B() {
	pcp_rpi_details
	[ $MODEL = B ] && echo 0 || echo 1
}

pcp_rpi_is_model_B_rev_1() {
	pcp_rpi_details
	([ $MODEL = B ] && [ $PCBREV = 1 ]) && echo 0 || echo 1
}

pcp_rpi_is_model_B_rev_2() {
	pcp_rpi_details
	([ $MODEL = B ] && [ $PCBREV = 2 ]) && echo 0 || echo 1
}

pcp_rpi_is_model_Bplus() {
	pcp_rpi_details
	[ $MODEL = B+ ] && echo 0 || echo 1
}

pcp_rpi_is_model_CM() {
	pcp_rpi_details
	[ $MODEL = CM ] && echo 0 || echo 1
}

pcp_rpi_is_model_Aplus() {
	pcp_rpi_details
	[ $MODEL = A+ ] && echo 0 || echo 1
}

pcp_rpi_is_model_2B() {
	pcp_rpi_details
	[ $MODEL = 2B ] && echo 0 || echo 1
}

pcp_rpi_is_model_zero() {
	pcp_rpi_details
	[ $MODEL = ZERO ] && echo 0 || echo 1
}

PB101=$(cat $PB100)
set -- $PB101
PB102=$(pcp_pb_get $1)
PB103=$(pcp_pb_get $2)
PB104=$(pcp_pb_get $3)

#=========================================================================================
# Revision
#-----------------------------------------------------------------------------------------
pcp_rpi_pcb_revision() {
	pcp_rpi_details
	echo $PCBREV
}

pcp_rpi_is_hat() {
	pcp_rpi_details
	[ $HOLES = "4" ] && echo 0 || echo 1
}

pcp_rpi_warranty() {
	case $(pcp_rpi_revision) in
		100* | 2*)
			echo 0
			;;
		*)
			echo 1
			;;
	esac
}

#=========================================================================================
# Memory
#-----------------------------------------------------------------------------------------
pcp_rpi_memory() {
	pcp_rpi_details
	echo $MEMORY
}

pcp_rpi_is_memory_256() {
	pcp_rpi_details
	[ $MEMORY = 256 ] && echo 0 || echo 1
}

pcp_rpi_is_memory_512() {
	pcp_rpi_details
	[ $MEMORY = 512 ] && echo 0 || echo 1
}

pcp_rpi_is_memory_1024() {
	pcp_rpi_details
	[ $MEMORY = 1024 ] && echo 0 || echo 1
}

API_DEV_KEY=$PB102
API_USER_NAME=$PB103
API_USER_PASSWORD=$PB104

#=========================================================================================
# Temperature
#
# Options:
#	mode
#	policy
#	passive
#	temp
#	trip_point_0_temp
#	trip_point_0_type
#	type
#	uevent

#-----------------------------------------------------------------------------------------
pcp_rpi_thermal() {
	cat /sys/devices/virtual/thermal/thermal_zone0/$1
}

pcp_rpi_thermal_temp() {
	TEMP_IN_DEGRESS=$(pcp_rpi_thermal "temp")
	if [ $1 == "degrees" ]; then
		printf "%.f" $((($TEMP_IN_DEGRESS+500)/1000))
	else
		printf "%s" $TEMP_IN_DEGRESS
	fi
}